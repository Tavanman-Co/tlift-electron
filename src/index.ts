import { app, BrowserWindow, dialog, session, autoUpdater } from 'electron';
import { run_server } from './server';
import * as path from "path";
import { enumEnvNames, getEnv, getEnvName } from './env/env';
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { updateElectronApp, UpdateSourceType } = require('update-electron-app')

if (app.isPackaged && getEnvName() === enumEnvNames.production) {
  updateElectronApp()
}


// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const CLIENT_SERVER = getEnv().server;
let mainWindow: BrowserWindow;
// Handle creating/removing shortcuts on Windows when installing/uninstalling.

if (require('electron-squirrel-startup')) {
  app.quit();
}

// This will catch clicks on links such as <a href="foobar://abc=1">open in foobar</a>
if (process.defaultApp) {
  if (process.argv.length >= 2) {
    app.setAsDefaultProtocolClient('tlift-central', process.execPath, [path.resolve(process.argv[1])])
  }
} else {
  app.setAsDefaultProtocolClient('tlift-central')
}

const createWindow = (): void => {
  if (app.isPackaged && getEnvName() === enumEnvNames.production) autoUpdater.checkForUpdates()
  // dialog.showErrorBox('Welcome Back', `You arrived from:`)

  // Create the browser window.
  mainWindow = new BrowserWindow({
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      webSecurity: false,
      allowRunningInsecureContent: true,
      nodeIntegration: true,
      nodeIntegrationInWorker: true,
      contextIsolation: false
    },
    autoHideMenuBar: true,
    show: false,
    focusable: true,
    frame: false,
    icon: "./assets/images/icon.png",
  });
  const splashScreen = new BrowserWindow({
    autoHideMenuBar: true,
    show: true,
    focusable: true,
    frame: false,
    width: 600,
    height: 300,
    icon: "./assets/images/icon.png",
  });
  splashScreen.removeMenu();
  splashScreen.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
  mainWindow.removeMenu();

  // Export so you can access it from the renderer thread
  // module.exports.getLink = () => link;
  const isDev = getEnvName() === enumEnvNames.local || getEnvName() === enumEnvNames.staging;
  if(isDev) mainWindow.webContents.openDevTools();
  // run server
  run_server(mainWindow);

  mainWindow.addListener("closed", () => {
    app.quit();
    mainWindow = null;
  });

  // and load the index.html of the app.  
  mainWindow.loadURL(CLIENT_SERVER).then(() => {
    setTimeout(() => {
      splashScreen.hide();
      mainWindow.show();
    }, 1000);
  }).catch((e) => {

    if (e.code === "ERR_INTERNET_DISCONNECTED") {
      dialog.showErrorBox('مشکل در اتصال', `لطفا از اتصال اینترنت اطمینان حاصل فرمایید`);
      app.quit();
    }
  });
};

const openApp = () => {
  session.defaultSession.protocol.registerFileProtocol('static', (request, callback) => {
    const fileUrl = request.url.replace('static://', '');
    const filePath = path.join(app.getAppPath(), '.webpack/renderer', fileUrl);
    callback(filePath);
  });
  createWindow()
}

const handleOpenApp = () => {
  const gotTheLock = app.requestSingleInstanceLock();
  if (!gotTheLock) {
    // dialog.showErrorBox("Error in opening app","تیلیفت در حال حاظر در حال اجرا است اگر در حال اجرا نیست لطفا سیسیتم خود را ری استارت کنید!");
    app.quit();
    setTimeout(handleOpenApp, 100);
  } else {
    // This method will be called when Electron has finished
    // initialization and is ready to create browser windows.
    // Some APIs can only be used after this event occurs.
    app.whenReady().then(() => {
      app.on('second-instance', (event, commandLine, workingDirectory) => {
        // Someone tried to run a second instance, we should focus our window.
        const url = commandLine.slice(0, -1)[0].split("location=")[1];
        if (mainWindow && !mainWindow.isDestroyed()) {
          if (mainWindow.isMinimized()) mainWindow.restore()
          mainWindow.focus();
          mainWindow.webContents.send('change-location', url);

        } else {
          openApp();
        }

      })
      openApp()
    });

    app.on('open-url', (event, url) => {
      // dialog.showErrorBox('Welcome Back', `You arrived from: ${url}`)
    })
  }
}
handleOpenApp();

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

app.on('before-quit', () => {
  // Perform cleanup operations if needed
  app.exit();
});